<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1" />
<title>Anki Cram ‚Äî Mobile</title>
<meta name="theme-color" content="#0b0f14">
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0f14; --panel:#111722; --ink:#e8ecf1; --muted:#91a4b8;
    --border:#223046; --shadow:0 10px 30px rgba(0,0,0,.35);
    --again:#ef4444; --hard:#f59e0b; --good:#10b981; --easy:#2563eb;
    --btn:#142033; --btnHover:#1b2b44; --radius:16px;
    --fw: clamp(15px, 2.7vw, 18px);
    --card-fs: clamp(16px, 3.6vw, 22px);
    --head-fs: clamp(14px, 3vw, 18px);
    --topbar-h: 56px;
    --statsbar-h: 46px;
    --toolbar-h: 84px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent}
  html,body{height:100%}
  html{overflow:hidden}
  body{
    margin:0;
    font: var(--fw)/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--ink);
    background:linear-gradient(180deg,#0b0f14,#0d1219 30%,#0c1118);
    min-height:100dvh;
    display:flex;
    flex-direction:column;
    -webkit-text-size-adjust:100%;
  }

  header.topbar{
    height:var(--topbar-h);
    display:flex;
    align-items:center;
    gap:.35rem;
    padding:0 .45rem;
    background:rgba(11,15,20,.9);
    backdrop-filter: blur(8px);
    border-bottom:1px solid #162234;
    overflow:hidden;
    flex-wrap:nowrap;
  }
  .brand{
    display:flex;
    align-items:center;
    gap:.18rem;
    font-weight:700;
    font-size:var(--head-fs);
    white-space:nowrap;
    flex:0 0 auto;
  }
  .brand-poli{color:#fff; letter-spacing:.1px}
  .brand-trauma{
    font-weight:800;
    background: linear-gradient(90deg,#ff0040,#ff7a00,#ffd400,#00d17a,#0096ff,#9b5cff,#ff3cd1);
    background-size: 200% 100%;
    background-position: 0% 50%;
    -webkit-background-clip:text;
    background-clip:text;
    -webkit-text-fill-color: transparent;
    color:transparent;
    letter-spacing:.15px;
    animation: rainbowSlide 6s linear infinite;
  }
  @keyframes rainbowSlide{
    0%{background-position:0% 50%}
    100%{background-position:200% 50%}
  }

  .spacer{flex:1 1 auto; min-width:0}
  input[type=file]{display:none}
  .btn{
    border:1px solid #2a3a4f;
    background:var(--btn);
    color:var(--ink);
    padding:.32rem .5rem;
    border-radius:10px;
    cursor:pointer;
    transition:background .15s, transform .06s;
    font-size: clamp(11px, 2.6vw, 13px);
    line-height:1;
    white-space:nowrap;
    flex:0 0 auto;
    max-width:64px;
    text-overflow:ellipsis;
    overflow:hidden;
  }
  header.topbar .btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    height:30px;
  }
  .btn:hover{background:var(--btnHover)}
  .btn:active{transform:translateY(1px)}
  .btn.danger{border-color:#5b1a1a}

  /* A√∫n m√°s compacto en pantallas muy estrechas */
  @media (max-width:480px){
    header.topbar{
      gap:.25rem;
      padding:0 .35rem;
    }
    .brand{
      font-size:12px;
      max-width:82px;
      text-overflow:ellipsis;
      overflow:hidden;
    }
    header.topbar .btn{
      padding:.22rem .35rem;
      font-size:10px;
      max-width:52px;
      height:26px;
    }
  }

  .statsbar{
    height:var(--statsbar-h);
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:.5rem;
    align-items:center;
    padding:.35rem .8rem;
    border-bottom:1px solid #162234;
    background:rgba(12,17,24,.75);
    backdrop-filter: blur(6px);
  }
  .chip{
    justify-self:stretch;
    text-align:center;
    padding:.25rem .5rem;
    border:1px solid #263447;
    border-radius:999px;
    color:#9cb2c9;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  main{
    position:relative;
    height: calc(100dvh - var(--topbar-h) - var(--statsbar-h) - var(--toolbar-h) - env(safe-area-inset-bottom));
    padding:.8rem;
    overflow:hidden;
  }
  .cardwrap{
    position:relative;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#0c1118,#0a0f16);
    border:1px solid var(--border);
    border-radius:var(--radius);
    overflow:hidden;
  }
  .dropzone{
    color:#a7b6c7;
    text-align:center;
    padding:1rem;
    width:100%;
    font-size:.9rem;
  }

  .stack{
    position:relative;
    width:min(96%, 760px);
    height:min(96%, 100%);
  }
  .card{
    position:absolute;
    inset:0;
    border-radius:14px;
    padding:1.1rem 1.2rem;
    user-select:none;
    touch-action:none;
    background:
      radial-gradient(1200px 400px at 50% -10%, rgba(99,179,237,.08), transparent),
      linear-gradient(180deg,#0e1520,#0b1117 40%,#0a0f15);
    border:1px solid #1e2a3c;
    box-shadow:var(--shadow);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    transition: transform .22s ease, opacity .22s ease;
    will-change: transform, opacity;
  }
  .cardBelow{
    filter:saturate(.96) brightness(.985);
    opacity:.97;
  }
  .badge{
    position:absolute;
    right:.8rem;
    top:.8rem;
    font-size:.9rem;
    color:#b4c5d6;
    pointer-events:none;
  }
  .card h2{
    margin:0 0 .5rem;
    font-size: clamp(15px, 3.2vw, 20px);
    color:#cfe3ff;
  }

  .face{
    white-space:pre-wrap;
    font-size: var(--card-fs);
    line-height:1.5;
    overflow:auto;
    padding-bottom:1rem;
    scrollbar-width: thin;
    text-shadow:none !important;
    background:transparent !important;
    -webkit-user-select:text;
    user-select:text;
  }
  .face::-webkit-scrollbar{width:8px}
  .face::-webkit-scrollbar-thumb{
    background:#1b2740;
    border-radius:8px;
  }

  .swipe-hint{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    letter-spacing:.3px;
    color:#fff;
    mix-blend-mode:screen;
    text-shadow:0 2px 16px rgba(0,0,0,.35);
    opacity:0;
    border-radius:inherit;
    pointer-events:none;
    transition: opacity .06s linear;
  }
  @keyframes hintFlash{
    0%{opacity:0}
    18%{opacity:1}
    82%{opacity:1}
    100%{opacity:0}
  }
  .flash{ animation: hintFlash .5s ease-in-out both }
  .hint-left {background:linear-gradient(90deg,  rgba(239,68,68,.65),  transparent)}
  .hint-right{background:linear-gradient(270deg, rgba(37,99,235,.65), transparent)}
  .hint-up   {background:linear-gradient(180deg, rgba(16,185,129,.65), transparent)}
  .hint-down {background:linear-gradient(0deg,   rgba(245,158,11,.65), transparent)}

  .exit-left { transform: translateX(-130%) rotate(-6deg); opacity:0 }
  .exit-right{ transform: translateX(130%)  rotate( 6deg); opacity:0 }
  .exit-up   { transform: translateY(-130%) rotate(-3deg); opacity:0 }
  .exit-down { transform: translateY(130%) rotate( 3deg); opacity:0 }
  .notrans   { transition:none !important }
  .noanim    { animation:none !important }

  nav.toolbar{
    position:fixed;
    left:0; right:0; bottom:0;
    z-index:40;
    background:linear-gradient(180deg,rgba(9,13,18,.4),rgba(9,13,18,.92));
    backdrop-filter: blur(12px);
    border-top:1px solid #162234;
    padding:.6rem .8rem calc(.6rem + env(safe-area-inset-bottom));
  }
  .rowBtns{
    display:grid;
    grid-template-columns:repeat(4, 1fr);
    gap:.6rem;
  }
  .tbtn{
    display:flex;
    align-items:center;
    justify-content:center;
    padding:clamp(14px, 3.6vw, 18px) .4rem;
    font-size:clamp(14px, 3.2vw, 18px);
    border-radius:14px;
    color:#f2f6fb;
    border:1px solid transparent;
  }
  .again{background:linear-gradient(180deg,#dc2626,#991b1b)}
  .hard {background:linear-gradient(180deg,#d97706,#9a3f05)}
  .good {background:linear-gradient(180deg,#059669,#047857)}
  .easy {background:linear-gradient(180deg,#1d4ed8,#1e40af)}
  .tiny{
    font-size:.9rem;
    color:#91a4b8;
    margin-top:.35rem;
    text-align:center;
  }

  .sheet-panel{
    position:fixed;
    left:0; right:0; bottom:0;
    z-index:50;
    transform:translateY(110%);
    transition: transform .25s ease;
    background:linear-gradient(180deg,rgba(12,17,24,.98),rgba(10,14,20,.98));
    border-top:1px solid #162234;
    border-radius:16px 16px 0 0;
    padding:1rem .9rem;
    max-height:80dvh;
    overflow:auto;
  }
  .sheet-open .sheet-panel{ transform:translateY(0) }
  .sheet-head{
    display:flex;
    align-items:center;
    gap:.6rem;
    margin-bottom:.6rem;
  }
  .sheet-title{font-weight:700}
  .grid2{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:.6rem;
  }
  textarea{
    width:100%;
    min-height:110px;
    resize:vertical;
    color:#e8ecf1;
    background:#0c1218;
    border:1px solid #203249;
    border-radius:10px;
    padding:.7rem;
    font-family:inherit;
  }

  input, select, textarea { font-size:16px }

  .card, .card * { -webkit-touch-callout:none }
</style>
</head>
<body oncontextmenu="return false">

<header class="topbar">
  <div class="brand" aria-label="poli trauma T">
    <span class="brand-poli">poli</span><span class="brand-trauma">[traumaT]</span>
  </div>
  <div class="spacer"></div>
  <input type="file" id="file" accept=".csv,.json,text/csv,application/json" />
  <label for="file" class="btn" title="Importar CSV/JSON">üì•</label>
  <button class="btn" id="exportBtn" title="Exportar JSON">üì§</button>
  <button class="btn" id="resetBtn" title="Resetear progreso">üîô</button>
  <button class="btn danger" id="wipeAllBtn" title="Borrar TODO">üóëÔ∏è</button>
  <button class="btn" id="openSettingsBtn" title="Ajustes">‚öôÔ∏è</button>
</header>

<div class="statsbar">
  <div class="chip">Restantes: <b id="remStat">0</b></div>
  <div class="chip">Hechas: <b id="doneStat">0</b></div>
  <div class="chip">Dominadas: <b id="masteredStat">0</b></div>
</div>

<main>
  <section class="cardwrap" id="dropzone">
    <div class="stack" id="stack" style="display:none">
      <article class="card cardBelow" id="cardBelow" aria-hidden="true">
        <div class="badge" id="sideBadgeBelow">Frente</div>
        <h2 id="cardTitleBelow">Frente</h2>
        <div class="face" id="cardFaceBelow"></div>
      </article>
      <article class="card cardTop" id="cardTop" aria-live="polite">
        <div class="badge" id="sideBadge">Frente</div>
        <h2 id="cardTitle">Frente</h2>
        <div class="face" id="cardFace"></div>
        <div class="swipe-hint" id="swHint"></div>
      </article>
    </div>
    <div class="dropzone" id="dzHelp">
      <b>Usa ‚Äúüì•‚Äù para cargar tu baraja (CSV o JSON).</b>
      <div>Si no hay cabecera Front,Back, se usa 1¬™ columna como Frente y 2¬™ como Reverso.</div>
      <div>Elige el separador y el modo de ‚Äúadivinar‚Äù en Ajustes.</div>
    </div>
  </section>

  <div class="sheet-panel" id="settingsPanel">
    <div class="sheet-head">
      <div class="sheet-title">Ajustes de sesi√≥n</div>
      <div class="spacer"></div>
      <button class="btn" id="closeSettingsBtn" title="Cerrar ajustes">‚úñ</button>
    </div>

    <div class="grid2">
      <label>Again +<input id="againPos" type="number" inputmode="numeric" value="2" min="1" class="btn" style="width:100%"></label>
      <label>Hard +<input  id="hardPos"  type="number" inputmode="numeric" value="5" min="1" class="btn" style="width:100%"></label>
      <label>Good ‚Üí<input  id="goodPos"  type="text"   value="10" class="btn" style="width:100%"></label>
      <label>Easy ‚Üí<input  id="easyPos"  type="text"   value="end" class="btn" style="width:100%"></label>
      <label>Aciertos para dominar
        <input id="passesNeeded" type="number" inputmode="numeric" value="1" min="1" max="10" class="btn" style="width:100%">
      </label>
      <label>Orden inicial
        <select id="orderSelect" class="btn" style="width:100%">
          <option value="shuffle">Aleatorio</option>
          <option value="original">Original</option>
        </select>
      </label>
    </div>

    <div style="height:.8rem"></div>

    <h3 style="margin:0 0 .4rem">Modo de adivinanza</h3>
    <div style="display:flex; gap:.6rem; align-items:center; flex-wrap:wrap; margin-bottom:.4rem">
      <span>Adivinar:</span>
      <select id="guessSelect" class="btn" style="padding:.25rem .5rem; max-width:none">
        <option value="back">reverso</option>
        <option value="front">frente</option>
        <option value="both">ambos</option>
      </select>
      <span style="font-size:.8rem; color:#9cb2c9">
        ‚ÄúAmbos‚Äù muestra cada carta dos veces: una por cada lado.
      </span>
    </div>

    <h3 style="margin:.4rem 0 .4rem">Separador y pegado</h3>
    <div style="display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; margin-bottom:.4rem">
      <span>Separador CSV:</span>
      <select id="sepSelect" class="btn" style="padding:.25rem .5rem; max-width:none">
        <option value=",">,</option>
        <option value=";">;</option>
        <option value=":">:</option>
        <option value="-">-</option>
      </select>
    </div>

    <textarea id="pasteArea" placeholder="Pega CSV (con el separador elegido, con o sin Front,Back) o JSON compatible..."></textarea>

    <div style="margin-top:.5rem; display:flex; gap:.6rem; flex-wrap:wrap">
      <button class="btn" id="loadPasteBtn">Cargar desde texto</button>
      <button class="btn" id="reshuffleBtn" title="Rebarajar cola">üé≤ Rebarajar</button>
    </div>

    <div style="margin-top:.7rem; display:flex; gap:.6rem; flex-wrap:wrap; justify-content:flex-end">
      <button class="btn" id="applySettingsBtn" title="Aplicar ajustes de sesi√≥n">Aplicar ajustes</button>
    </div>
  </div>
</main>

<nav class="toolbar" id="toolbar">
  <div class="rowBtns" id="rowBtns">
    <button class="tbtn again" id="againBtn" aria-label="Again">Again</button>
    <button class="tbtn hard"  id="hardBtn"  aria-label="Hard">Hard</button>
    <button class="tbtn good"  id="goodBtn"  aria-label="Good">Good</button>
    <button class="tbtn easy"  id="easyBtn"  aria-label="Easy">Easy</button>
  </div>
  <div class="tiny">Gestos: ‚¨Ö Again ¬∑ ‚¨Ü Good ¬∑ ‚¨á Hard ¬∑ ‚û° Easy ‚Äî Toca la carta para voltear.</div>
</nav>

<script>
const uid = ()=> Math.random().toString(36).slice(2)+Date.now().toString(36);

function parseCSV(text, sep){
  const S = sep || ',';
  const rows=[];
  let i=0, field='', row=[], inQuotes=false;
  while(i < text.length){
    const c = text[i];
    if(inQuotes){
      if(c === '"'){
        if(text[i+1] === '"'){ field += '"'; i+=2; continue; }
        inQuotes = false; i++; continue;
      }
      field += c; i++; continue;
    } else {
      if(c === '"'){ inQuotes = true; i++; continue; }
      if(c === S){ row.push(field); field=''; i++; continue; }
      if(c === '\r'){ i++; continue; }
      if(c === '\n'){
        row.push(field); rows.push(row);
        row=[]; field=''; i++; continue;
      }
      field += c; i++;
    }
  }
  row.push(field); rows.push(row);
  while(rows.length && rows[rows.length-1].every(x => (x||'').trim()==='')) rows.pop();
  return rows;
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}
const clamp=(v,min,max)=> Math.max(min, Math.min(max, v));

const remStat        = document.getElementById('remStat');
const doneStat       = document.getElementById('doneStat');
const masteredStat   = document.getElementById('masteredStat');

const againBtn       = document.getElementById('againBtn');
const hardBtn        = document.getElementById('hardBtn');
const goodBtn        = document.getElementById('goodBtn');
const easyBtn        = document.getElementById('easyBtn');

const openSettingsBtn  = document.getElementById('openSettingsBtn');
const closeSettingsBtn = document.getElementById('closeSettingsBtn');

const againPos      = document.getElementById('againPos');
const hardPos       = document.getElementById('hardPos');
const goodPos       = document.getElementById('goodPos');
const easyPos       = document.getElementById('easyPos');
const passesNeeded  = document.getElementById('passesNeeded');
const orderSelect   = document.getElementById('orderSelect');
const guessSelect   = document.getElementById('guessSelect');
const sepSelect     = document.getElementById('sepSelect');

const pasteArea     = document.getElementById('pasteArea');
const loadPasteBtn  = document.getElementById('loadPasteBtn');
const reshuffleBtn  = document.getElementById('reshuffleBtn');
const applySettingsBtn = document.getElementById('applySettingsBtn');

const fileInput     = document.getElementById('file');
const exportBtn     = document.getElementById('exportBtn');
const resetBtn      = document.getElementById('resetBtn');
const wipeAllBtn    = document.getElementById('wipeAllBtn');

const bodyEl        = document.body;

function getSelectedSep(){
  return (sepSelect && sepSelect.value) ? sepSelect.value : ',';
}

/* ===== Estado ===== */
const STORAGE_KEY='ankiCram.mobile.v15.progress';
let app={
  version: 3,
  deckName:'Sin baraja',
  cards:[],
  queue:[], // [{id, showBack}]
  stats:{done:0, mastered:0},
  cfg:{
    againPos:2,
    hardPos:5,
    goodPos:10,
    easyPos:'end',
    passesNeeded:1,
    order:'shuffle',
    guessMode:'back'
  },
  meta:{},
  peekNextEntry:null,
  freezeBelow:false,
  animating:false
};

function cardById(id){
  return app.cards.find(c=>c.id===id) || null;
}
function currentEntry(){ return app.queue[0] || null; }
function queueNextEntry(){ return app.queue[1] || null; }
function currentCard(){
  const e = currentEntry();
  return e ? cardById(e.id) : null;
}

/* ===== Migraci√≥n / Persistencia ===== */
function makeEntryForId(id, cfg){
  if(cfg.guessMode === 'front') return {id, showBack:true};
  if(cfg.guessMode === 'back')  return {id, showBack:false};
  return {id, showBack:false};
}

function sanitizeQueue(raw, cfg, cards){
  const validIds = new Set(cards.map(c=>c.id));
  const out=[];
  const src = Array.isArray(raw) ? raw : [];

  for(const item of src){
    if(!item) continue;
    if(typeof item === 'string' || typeof item === 'number'){
      const id = String(item);
      if(!validIds.has(id)) continue;
      out.push(makeEntryForId(id, cfg));
    } else if(typeof item === 'object' && typeof item.id === 'string'){
      if(!validIds.has(item.id)) continue;
      let showBack = !!item.showBack;
      if(cfg.guessMode === 'front') showBack = true;
      else if(cfg.guessMode === 'back') showBack = false;
      out.push({id:item.id, showBack});
    }
  }

  if(!out.length){
    if(cfg.guessMode === 'both'){
      for(const c of cards){
        out.push({id:c.id, showBack:false});
        out.push({id:c.id, showBack:true});
      }
    }else if(cfg.guessMode === 'front'){
      for(const c of cards) out.push({id:c.id, showBack:true});
    }else{
      for(const c of cards) out.push({id:c.id, showBack:false});
    }
  }

  if(cfg.order === 'shuffle') shuffle(out);
  return out;
}

function migrateAndSanitize(obj){
  let out = {...app, ...obj};
  out.version = 3;

  out.cards = (out.cards||[]).map(c=>({
    id: c.id || uid(),
    front: c.front ?? '',
    back:  c.back  ?? ''
  }));

  out.cfg = {...app.cfg, ...(out.cfg||{})};

  if(!out.cfg.guessMode){
    if(out.cfg.showStart === 'back') out.cfg.guessMode = 'front';
    else out.cfg.guessMode = 'back';
  }
  if(!['front','back','both'].includes(out.cfg.guessMode)){
    out.cfg.guessMode = 'back';
  }
  if(out.cfg.order !== 'original' && out.cfg.order !== 'shuffle'){
    out.cfg.order = 'shuffle';
  }

  const meta={};
  for(const c of out.cards){
    const m=(out.meta||{})[c.id]||{};
    const streak = m.streak|0;
    meta[c.id]={
      seen: m.seen|0,
      streak,
      correct: m.correct|0,
      remaining: Math.max(1, (out.cfg.passesNeeded ?? app.cfg.passesNeeded) - streak)
    };
  }
  out.meta = meta;

  out.queue = sanitizeQueue(out.queue, out.cfg, out.cards);

  out.stats = {
    done: out.stats?.done|0,
    mastered: out.stats?.mastered|0
  };

  out.peekNextEntry=null;
  out.freezeBelow=false;
  out.animating=false;

  return out;
}

const saveSession = ()=>{
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(app)); }catch(e){}
};

function loadSession(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    const data = JSON.parse(raw);
    if(!data) return false;
    app = migrateAndSanitize(data);
    syncSettingsUIFromCfg();
    renderAll();
    return true;
  }catch(e){
    return false;
  }
}

/* ===== Cola seg√∫n ajustes ===== */
function buildQueue(){
  const mode = app.cfg.guessMode || 'back';
  const q = [];

  if(!app.cards.length){
    app.queue = [];
    app.meta = {};
    app.stats = {done:0, mastered:0};
    app.peekNextEntry = null;
    app.freezeBelow = false;
    app.animating = false;
    return;
  }

  if(mode === 'both'){
    for(const c of app.cards){
      q.push({id:c.id, showBack:false});
      q.push({id:c.id, showBack:true});
    }
  }else if(mode === 'front'){
    for(const c of app.cards) q.push({id:c.id, showBack:true});
  }else{
    for(const c of app.cards) q.push({id:c.id, showBack:false});
  }

  if(app.cfg.order === 'shuffle') shuffle(q);

  app.queue = q;
  app.meta = {};
  for(const c of app.cards){
    app.meta[c.id]={seen:0, streak:0, correct:0, remaining:app.cfg.passesNeeded};
  }
  app.stats = {done:0, mastered:0};
  app.peekNextEntry = null;
  app.freezeBelow = false;
  app.animating = false;
}

/* ===== Render ===== */
function renderStats(){
  remStat.textContent = String(app.queue.length);
  doneStat.textContent = String(app.stats.done||0);
  masteredStat.textContent = String(app.stats.mastered||0);
}

function fillCard(prefix, cardObj, showBack){
  const badge = document.getElementById(prefix==='Top' ? 'sideBadge' : 'sideBadgeBelow');
  const title = document.getElementById(prefix==='Top' ? 'cardTitle' : 'cardTitleBelow');
  const face  = document.getElementById(prefix==='Top' ? 'cardFace' : 'cardFaceBelow');
  const art   = document.getElementById('card'+prefix);

  if(!cardObj){
    art.style.display='none';
    face.textContent='';
    return;
  }
  art.style.display='flex';
  const isBack = !!showBack;
  const label = isBack ? 'Reverso' : 'Frente';
  badge.textContent = label;
  title.textContent = label;
  face.textContent  = isBack ? (cardObj.back || '') : (cardObj.front || '');
  face.scrollTop = 0;
}

function renderStack(){
  const stack = document.getElementById('stack');
  const help  = document.getElementById('dzHelp');

  const entry = currentEntry();
  const card = entry ? cardById(entry.id) : null;

  if(!card){
    stack.style.display='none';
    help.style.display='block';
    return;
  }
  help.style.display='none';
  stack.style.display='block';

  clearHint();

  fillCard('Top', card, entry.showBack);

  let nextEntry = (app.freezeBelow && app.peekNextEntry) ? app.peekNextEntry : queueNextEntry();
  if(nextEntry && !cardById(nextEntry.id)) nextEntry = null;
  const nextCard = nextEntry ? cardById(nextEntry.id) : null;
  fillCard('Below', nextCard, nextEntry ? nextEntry.showBack : false);
}

function renderAll(){
  renderStats();
  renderStack();
}

/* ===== Hint ===== */
const hintEl = ()=> document.getElementById('swHint');

function setHintDirOpacity(dir, opa){
  const h = hintEl();
  h.classList.remove('flash');
  h.classList.add('noanim');
  h.className = 'swipe-hint ' + (
    dir==='left'  ? 'hint-left' :
    dir==='right' ? 'hint-right' :
    dir==='up'    ? 'hint-up' :
                    'hint-down'
  );
  h.style.opacity = String(clamp(opa,0,1));
}
function clearHint(){
  const h = hintEl();
  h.classList.add('noanim');
  h.classList.remove('flash','hint-left','hint-right','hint-up','hint-down');
  h.className = 'swipe-hint';
  h.style.opacity='0';
  void h.offsetHeight;
  h.classList.remove('noanim');
}
function flashHintFinal(dir){
  const h = hintEl();
  h.classList.remove('noanim','flash');
  h.className = 'swipe-hint ' + (
    dir==='left'  ? 'hint-left' :
    dir==='right' ? 'hint-right' :
    dir==='up'    ? 'hint-up' :
                    'hint-down'
  );
  void h.offsetWidth;
  h.classList.add('flash');
  setTimeout(clearHint, 520);
}

/* ===== Cola movimiento ===== */
function moveCurrent(delta){
  if(app.queue.length <= 1) return;
  const entry = app.queue.shift();
  if(delta === 'end'){
    app.queue.push(entry);
  }else{
    const pos = Math.max(0, Math.min(app.queue.length, parseInt(delta||0,10)));
    app.queue.splice(pos, 0, entry);
  }
}
function removeCurrentAsMastered(){
  app.queue.shift();
  app.stats.mastered += 1;
}

/* ===== Grading ===== */
function performGrade(action){
  const entry = currentEntry();
  const card = currentCard();
  if(!entry || !card) return;
  const id = entry.id;

  const m = app.meta[id] || (app.meta[id] = {
    seen:0, streak:0, correct:0, remaining:app.cfg.passesNeeded
  });
  m.seen += 1;

  if(action==='again'){
    m.streak=0;
    app.stats.done+=1;
    moveCurrent(app.cfg.againPos);
  } else if(action==='hard'){
    m.streak=Math.max(0, m.streak-1);
    app.stats.done+=1;
    moveCurrent(app.cfg.hardPos);
  } else if(action==='good'){
    m.streak+=1;
    m.correct+=1;
    m.remaining = Math.max(1, app.cfg.passesNeeded - m.streak);
    app.stats.done+=1;
    moveCurrent(app.cfg.goodPos);
  } else if(action==='easy'){
    m.streak+=2;
    m.correct+=1;
    m.remaining = Math.max(0, app.cfg.passesNeeded - m.streak);
    if(m.remaining===0){
      app.stats.done+=1;
      removeCurrentAsMastered();
    }else{
      moveCurrent(app.cfg.easyPos);
    }
  }
}

/* ===== Animaciones ===== */
function applyExit(action, dragState, done){
  const el = document.getElementById('cardTop');
  const {dx=0, dy=0} = dragState || {};
  const startRot = clamp(dx*0.06, -6, 6);

  el.style.transition='none';
  el.style.transform = `translate(${dx}px, ${dy}px) rotate(${startRot}deg)`;
  el.style.filter='';

  let endTransform = '';
  if(action==='again') endTransform = 'translateX(-130%) rotate(-6deg)';
  else if(action==='easy') endTransform = 'translateX(130%) rotate(6deg)';
  else if(action==='good') endTransform = 'translateY(-130%) rotate(-3deg)';
  else endTransform = 'translateY(130%) rotate(3deg)';

  const rect = document.getElementById('stack').getBoundingClientRect();
  const magNow = Math.hypot(dx,dy);
  const diag = Math.hypot(rect.width, rect.height);
  const remainRatio = clamp(1 - magNow/(diag*0.7), 0, 1);
  let dur = 200 + Math.round(140*remainRatio);
  dur = clamp(dur, 200, 340);

  let finished=false;
  const finish = ()=>{
    if(finished) return;
    finished=true;
    el.classList.add('notrans');
    el.style.transition='';
    el.style.transform='';
    el.style.opacity='';
    el.style.filter='';
    void el.offsetHeight;
    el.classList.remove('notrans');
    done && done();
  };

  requestAnimationFrame(()=>{
    el.style.transition = `transform ${dur}ms ease, opacity ${dur}ms ease`;
    el.style.transform  = endTransform;
    el.style.opacity    = '0';
  });

  const to = setTimeout(finish, dur+120);
  el.addEventListener('transitionend', ()=>{
    clearTimeout(to);
    finish();
  }, {once:true});
}

function swapNoTransition(mutator){
  const top = document.getElementById('cardTop');
  const below = document.getElementById('cardBelow');
  top.classList.add('notrans');
  below.classList.add('notrans');
  mutator && mutator();
  void top.offsetHeight;
  void below.offsetHeight;
  top.classList.remove('notrans');
  below.classList.remove('notrans');
}

function gradeFromDir(dir, currentDrag){
  if(app.animating) return;
  app.animating=true;

  const action =
    dir==='left'  ? 'again' :
    dir==='right' ? 'easy'  :
    dir==='up'    ? 'good'  : 'hard';

  flashHintFinal(dir);

  applyExit(action, currentDrag, ()=>{
    performGrade(action);
    app.peekNextEntry = null;
    app.freezeBelow = false;
    app.animating = false;

    swapNoTransition(()=>{
      clearHint();
      renderAll();
    });
    saveSession();
  });
}

/* ===== Gestos ===== */
(function gestures(){
  const el = document.getElementById('cardTop');
  let sx=0, sy=0, dx=0, dy=0, tracking=false, activePointer=null;
  const TAP_TH=18, COMMIT_TH=64, MAX_OPA_DIST=90;

  const direction=(dx,dy)=>
    (Math.abs(dx)>Math.abs(dy))
      ? (dx>0?'right':'left')
      : (dy>0?'down':'up');

  function start(x,y,e){
    if(app.animating || tracking) return;
    e.preventDefault?.();
    sx=x; sy=y; dx=0; dy=0;
    tracking=true;
    activePointer=e.pointerId ?? 'mouse';
    app.peekNextEntry = queueNextEntry();
    app.freezeBelow = true;
    swapNoTransition(()=> renderStack());
    el.style.transition='';
    el.style.filter='';
    el.setPointerCapture?.(e.pointerId);
  }

  function move(x,y,e){
    if(!tracking || app.animating) return;
    if(e && activePointer!=null && e.pointerId!==activePointer) return;
    dx = x - sx;
    dy = y - sy;

    const rot = clamp(dx*0.06, -6, 6);
    el.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;

    const mag = Math.hypot(dx,dy);
    const dir = direction(dx,dy);
    const ratio = clamp(mag / MAX_OPA_DIST, 0, 1);
    const strong = clamp(Math.pow(ratio, 0.6) * 1.35, 0, 1);
    setHintDirOpacity(dir, strong);

    const sat = 1 + strong * 0.45;
    const bright = 1 + strong * 0.18;
    el.style.filter = `saturate(${sat}) brightness(${bright})`;
  }

  function end(x,y,e){
    if(!tracking) return;
    if(e && activePointer!=null && e.pointerId!==activePointer) return;
    tracking=false;
    activePointer=null;

    const ddx = x - sx;
    const ddy = y - sy;
    const mag = Math.hypot(ddx,ddy);
    clearHint();
    el.style.filter='';
    e?.preventDefault?.();

    if(mag < TAP_TH){
      const entry = currentEntry();
      if(entry){
        entry.showBack = !entry.showBack;
        swapNoTransition(()=> renderStack());
      }
      el.style.transition='transform .14s ease';
      el.style.transform='';
      app.peekNextEntry = null;
      app.freezeBelow = false;
      return;
    }

    const dir = direction(ddx,ddy);
    if(mag >= COMMIT_TH){
      gradeFromDir(dir, {dx:ddx, dy:ddy});
    }else{
      el.style.transition='transform .16s ease';
      el.style.transform='';
      app.peekNextEntry = null;
      app.freezeBelow = false;
      clearHint();
      el.style.filter='';
    }
  }

  el.addEventListener('pointerdown', e=>start(e.clientX,e.clientY,e), {passive:false});
  el.addEventListener('pointermove',  e=>move(e.clientX, e.clientY, e), {passive:false});
  el.addEventListener('pointerup',    e=>end(e.clientX,  e.clientY,  e), {passive:false});
  el.addEventListener('pointercancel', ()=>{
    tracking=false;
    activePointer=null;
    clearHint();
    el.style.filter='';
  });
})();

/* ===== Botones respuesta ===== */
function freezeForButton(){
  if(app.animating) return;
  app.peekNextEntry = queueNextEntry();
  app.freezeBelow = true;
  swapNoTransition(()=> renderStack());
}
againBtn.onclick = ()=>{ freezeForButton(); gradeFromDir('left',  {dx:-80, dy:0}); };
hardBtn.onclick  = ()=>{ freezeForButton(); gradeFromDir('down',  {dx:0,  dy:80}); };
goodBtn.onclick  = ()=>{ freezeForButton(); gradeFromDir('up',    {dx:0,  dy:-80}); };
easyBtn.onclick  = ()=>{ freezeForButton(); gradeFromDir('right', {dx:80, dy:0}); };

/* ===== Ajustes (sheet) ===== */
openSettingsBtn.onclick  = ()=> bodyEl.classList.add('sheet-open');
closeSettingsBtn.onclick = ()=> bodyEl.classList.remove('sheet-open');

function syncSettingsUIFromCfg(){
  againPos.value = app.cfg.againPos;
  hardPos.value  = app.cfg.hardPos;
  goodPos.value  = app.cfg.goodPos;
  easyPos.value  = app.cfg.easyPos;
  passesNeeded.value = app.cfg.passesNeeded;
  orderSelect.value  = app.cfg.order || 'shuffle';
  guessSelect.value  = app.cfg.guessMode || 'back';
}

function applySettings(){
  const a = parseInt(againPos.value,10);
  const h = parseInt(hardPos.value,10);
  const gRaw = (goodPos.value || '').trim();
  const eRaw = (easyPos.value || '').trim();
  const p = parseInt(passesNeeded.value,10);

  app.cfg.againPos = (!isNaN(a) && a>=1) ? a : 2;
  app.cfg.hardPos  = (!isNaN(h) && h>=1) ? h : 5;

  const gNum = parseInt(gRaw,10);
  app.cfg.goodPos = isNaN(gNum) ? (gRaw || 'end') : gNum;

  const eNum = parseInt(eRaw,10);
  app.cfg.easyPos = isNaN(eNum) ? (eRaw || 'end') : eNum;

  app.cfg.passesNeeded = (!isNaN(p) && p>=1) ? p : 1;

  app.cfg.order = (orderSelect.value === 'original') ? 'original' : 'shuffle';

  const gm = guessSelect.value;
  app.cfg.guessMode = (gm === 'front' || gm === 'both') ? gm : 'back';

  buildQueue();
  renderAll();
  saveSession();
}

applySettingsBtn.onclick = applySettings;

/* ===== Import / Export ===== */
async function importText(text, nameGuess='Baraja'){
  const trimmed = text.trim();
  if(!trimmed) return;
  const sep = getSelectedSep();

  try{
    const obj = JSON.parse(trimmed);

    if(obj && (Array.isArray(obj.cards) || Array.isArray(obj.queue))){
      let restored = migrateAndSanitize(obj);
      restored.deckName = obj.deckName || nameGuess;
      app = restored;
      syncSettingsUIFromCfg();
      renderAll();
      saveSession();
      return;
    }

    if(Array.isArray(obj) && obj.length && (obj[0].front!==undefined || obj[0].Front!==undefined)){
      app.deckName = nameGuess;
      app.cards = obj.map(o=>({
        id: uid(),
        front: o.front ?? o.Front ?? '',
        back:  o.back  ?? o.Back  ?? ''
      }));
      buildQueue();
      renderAll();
      saveSession();
      return;
    }

    throw new Error('JSON no reconocido');
  }catch(_){
    const rows = parseCSV(trimmed, sep);
    if(!rows.length){ alert('CSV vac√≠o.'); return; }

    const clean = rows.filter(r => r.some(c => (c||'').trim() !== ''));
    if(!clean.length){ alert('CSV vac√≠o.'); return; }

    const header = clean[0].map(h => h.trim().toLowerCase());
    const hasFront = header.includes('front');
    const hasBack  = header.includes('back');
    const hasHeader = hasFront && hasBack;

    let iF, iB, startRow;
    if(hasHeader){
      iF = header.indexOf('front');
      iB = header.indexOf('back');
      startRow = 1;
    }else{
      iF = 0;
      iB = clean[0].length > 1 ? 1 : 0;
      startRow = 0;
    }

    const cards=[];
    for(let r=startRow; r<clean.length; r++){
      const row = clean[r];
      const front = (row[iF] ?? '').trim();
      const back  = (row[iB] ?? '').trim();
      if(front || back){
        cards.push({id:uid(), front, back});
      }
    }

    if(!cards.length){
      alert('No se encontraron tarjetas v√°lidas.');
      return;
    }

    app.deckName = nameGuess;
    app.cards = cards;
    buildQueue();
    renderAll();
    saveSession();
  }
}

fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const txt = await f.text();
  await importText(txt, f.name.replace(/\.(csv|txt|json)$/i,''));
  e.target.value = '';
});

loadPasteBtn.addEventListener('click', ()=>{
  const txt = pasteArea.value;
  if(!txt.trim()){
    alert('Pega contenido primero.');
    return;
  }
  importText(txt, 'Pegado ' + new Date().toLocaleString());
});

exportBtn.addEventListener('click', ()=>{
  if(!app.cards.length){
    alert('No hay nada que exportar.');
    return;
  }
  const payload = {
    version: app.version,
    deckName: app.deckName,
    exportedAt: new Date().toISOString(),
    cfg: app.cfg,
    stats: app.stats,
    cards: app.cards,
    meta: app.meta,
    queue: app.queue
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (app.deckName || 'baraja') + '.anki-cram.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
});

/* ===== Reset / Wipe ===== */
resetBtn.onclick = ()=>{
  if(!app.cards.length){
    alert('No hay baraja cargada.');
    return;
  }
  if(confirm('¬øResetear s√≥lo el progreso de esta baraja (estad√≠sticas y cola)?')){
    buildQueue();
    renderAll();
    saveSession();
  }
};

wipeAllBtn.onclick = ()=>{
  if(confirm('Esto eliminar√° TODAS las cartas y el progreso guardado.\n\n¬øSeguro que quieres continuar?')){
    app = {
      version: 3,
      deckName:'Sin baraja',
      cards:[],
      queue:[],
      stats:{done:0, mastered:0},
      cfg:{
        againPos:2,
        hardPos:5,
        goodPos:10,
        easyPos:'end',
        passesNeeded:1,
        order:'shuffle',
        guessMode:'back'
      },
      meta:{},
      peekNextEntry:null,
      freezeBelow:false,
      animating:false
    };
    try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
    syncSettingsUIFromCfg();
    renderAll();
  }
};

/* ===== Rebarajar desde ajustes ===== */
reshuffleBtn.addEventListener('click', ()=>{
  if(!app.queue.length){
    alert('No hay cartas para rebarajar.');
    return;
  }
  const cur = currentEntry();
  shuffle(app.queue);
  if(cur){
    const idx = app.queue.findIndex(e => e.id===cur.id && e.showBack===cur.showBack);
    if(idx>0){
      const [entry] = app.queue.splice(idx,1);
      app.queue.unshift(entry);
    }
  }
  renderAll();
  saveSession();
});

/* ===== Init ===== */
(function init(){
  if(!loadSession()){
    syncSettingsUIFromCfg();
    renderAll();
  }
})();
</script>
</body>
</html>
